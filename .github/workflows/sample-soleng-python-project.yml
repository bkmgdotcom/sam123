name: Sample Python GitHub
on:
  [workflow_dispatch]


permissions:
  actions: read # for detecting the Github Actions environment.
  packages: write # for uploading attestations.
  contents: read #Ability to read the contents permission
  security-events: write # Required for uploading code scanning 
  id-token: write      # required for SLSA generator

jobs:
    build-publish-python:
        permissions:
      # Needed to upload the results to code-scanning dashboard.
          security-events: write
      # Used to receive a badge. (Upcoming feature)
          id-token: write
      # Needs for private repositories.
          contents: read
          actions: read
        runs-on: ubuntu-latest
        env:
          JF_ACCESS_TOKEN: ${{ secrets.JF_ACCESS_TOKEN }}
          JF_USER_NAME: ${{ vars.JF_USER_NAME }}
          JF_ARTIFACTORY_URL: ${{ vars.JF_ARTIFACTORY_URL }}
          JF_PYTHON_REPOSITORY: ${{ vars.JF_PYTHON_REPOSITORY }}
          JF_DOCKER_REPOSITORY: ${{ vars.JF_DOCKER_REPOSITORY }}
          JF_APP_NAME: ${{ vars.JF_APP_NAME }}
          JF_PROJECT: ${{ vars.JF_PROJECT }}
          JF_PYTHON_MODULE_NAME: ${{ vars.JF_PYTHON_MODULE_NAME }}
          JF_PACKAGE_TAG: T_${{ github.run_number }}_${{ github.run_id }}
          JF_WORKING_DIRECTORY: ${{ vars.JF_SOLENG_WORKING_DIRECTORY }}
        outputs:
          image: ${{ env.JF_DOCKER_DOMAIN }}/${{ env.JF_DOCKER_REPOSITORY }}/${{ env.JF_APP_NAME }}
          digest: ${{ steps.build.outputs.digest }}
        steps:
            # Download the JFrog CLI and configure using JFrog Project and OIDC provider 
            - uses: jfrog/setup-jfrog-cli@v4
              name: Setup JFrog CLI
              id: setup-cli
              env:
                JF_URL: ${{ env.JF_ARTIFACTORY_URL }}
                JF_ACCESS_TOKEN: ${{ secrets.JF_ACCESS_TOKEN }}
                JF_PROJECT: ${{ env.JF_PROJECT }}
                  
            - name: Checkout the repository    
              uses: actions/checkout@v4

            - name: configure jfrog environment
              run: |
                cd ${{ env.JF_WORKING_DIRECTORY }}
                jf pip-config --repo-resolve=${{ env.JF_PYTHON_REPOSITORY }}  
                URL=$(echo ${{ env.JF_ARTIFACTORY_URL }} | sed 's|^https://||')
                echo "JF_DOCKER_DOMAIN=$URL" >> $GITHUB_ENV


            - name: configure environment
              run: |                      
                pwd
                python3 -m pip install --upgrade pip setuptools wheel sigstore
                wheel -h
                pip show setuptools
                echo $VIRTUAL_ENV

            - name: build project
              run: |                      
                pwd
                cd ${{ env.JF_WORKING_DIRECTORY }}
                jf pip install -r requirements.txt  --module=${{ env.JF_PYTHON_MODULE_NAME }} 
                python setup.py sdist bdist_wheel
                cd dist && echo "hashes=$(sha256sum * | base64 -w0)" >> $GITHUB_OUTPUT

            - name: publish python package
              run: |
                cd ${{ env.JF_WORKING_DIRECTORY }}
                jf rt u dist/ ${{ env.JF_PYTHON_REPOSITORY }}/ --build-name ${{ env.JF_APP_NAME }} --build-number ${{ env.JF_PACKAGE_TAG }} --module=${{ env.JF_PYTHON_MODULE_NAME }} --project ${{ env.JF_PROJECT }}

            - name: Set up Docker Buildx
              uses: docker/setup-buildx-action@v3    
                
            - name: Authenticate Docker
              uses: docker/login-action@v3
              with:
                registry: ${{ env.JF_ARTIFACTORY_URL }}
                username: ${{ env.JF_USER_NAME }}
                password: ${{ secrets.JF_ACCESS_TOKEN }}
    
                
            - name: Build Docker image    
              uses: docker/build-push-action@v6
              id: build
              with:
                push: true
                context: ${{ env.JF_WORKING_DIRECTORY }}
                platforms: linux/amd64 #, linux/arm64
                tags: ${{ env.JF_DOCKER_DOMAIN }}/${{ env.JF_DOCKER_REPOSITORY }}/${{ env.JF_APP_NAME }}:${{ env.JF_PACKAGE_TAG }}     
                build-args: |
                  JF_ARTIFACTORY_URL=${{ env.JF_ARTIFACTORY_URL }}
                  JF_USER_NAME=${{ env.JF_USER_NAME }}
                  JF_ACCESS_TOKEN=${{ secrets.JF_ACCESS_TOKEN }}

            - name: docker scan
              run: |  
                 cd ${{ env.JF_WORKING_DIRECTORY }}
                 jf docker pull ${{ env.JF_DOCKER_DOMAIN }}/${{ env.JF_DOCKER_REPOSITORY }}/${{ env.JF_APP_NAME }}:${{ env.JF_PACKAGE_TAG }}    
                 jf docker scan ${{ env.JF_DOCKER_DOMAIN }}/${{ env.JF_DOCKER_REPOSITORY }}/${{ env.JF_APP_NAME }}:${{ env.JF_PACKAGE_TAG }}                               

            - name: add docker package to build
              run: |  
                 cd ${{ env.JF_WORKING_DIRECTORY }}
                 echo "${{ env.JF_DOCKER_DOMAIN }}/${{ env.JF_DOCKER_REPOSITORY }}/${{ env.JF_APP_NAME }}:${{ env.JF_PACKAGE_TAG }}@${{ steps.build.outputs.digest }}" > metadata.json
                 jf rt build-docker-create ${{ env.JF_DOCKER_REPOSITORY }} --image-file metadata.json 
                 
            - name: publish build info
              run: |
                cd ${{ env.JF_WORKING_DIRECTORY }}
                jf rt bce 
                jf rt bp
                
            - name: build scan
              run: |            
                cd ${{ env.JF_WORKING_DIRECTORY }}
                jf build-scan --fail=false

            - name: "Run analysis"
              uses: ossf/scorecard-action@05b42c624433fc40578a4040d5cf5e36ddca8cde # v2.4.2
              with:
                results_file: results.sarif
                results_format: sarif
                # (Optional) Read-only PAT token. Uncomment the `repo_token` line below if:
                # - you want to enable the Branch-Protection check on a *public* repository, or
                # - you are installing Scorecards on a *private* repository
                # To create the PAT, follow the steps in https://github.com/ossf/scorecard-action#authentication-with-pat.
                # repo_token: ${{ secrets.SCORECARD_READ_TOKEN }}

                # Publish the results for public repositories to enable scorecard badges. For more details, see
                # https://github.com/ossf/scorecard-action#publishing-results.
                # For private repositories, `publish_results` will automatically be set to `false`, regardless
                # of the value entered here.
                publish_results: true        
            - name: "Upload artifact"
              uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
              with:
                name: SARIF file
                path: results.sarif
                retention-days: 5

            # Upload the results to GitHub's code scanning dashboard.
            - name: "Upload to code-scanning"
              uses: github/codeql-action/upload-sarif@ce28f5bb42b7a9f2c824e633a3f6ee835bab6858 # v3.29.0
              with:
                sarif_file: results.sarif


    provenance:
      needs: [build-publish-python]
      uses: slsa-framework/slsa-github-generator/.github/workflows/generator_container_slsa3.yml@v2.1.0
      with:
        image:  ${{ needs.build-publish-python.outputs.image }}
        digest: ${{ needs.build-publish-python.outputs.digest }}
        private-repository: true
      secrets:
        registry-username: ${{ vars.JF_USER_NAME }}
        registry-password: ${{ secrets.JF_ACCESS_TOKEN }}
